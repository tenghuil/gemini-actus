{
  "id": "web-db-user",
  "name": "Web App (db,user)",
  "description": "Full-stack web template with database + user flows",
  "capabilities": ["server", "db", "user"],
  "files": {
    "drizzle/schema.ts": "import { mysqlEnum, mysqlTable, text, timestamp, varchar } from \"drizzle-orm/mysql-core\";\n\n/**\n * Core user table backing auth flow.\n * Extend this file with additional tables as your product grows.\n * Columns use camelCase to match both database fields and generated types.\n */\nexport const users = mysqlTable(\"users\", {\n  id: varchar(\"id\", { length: 64 }).primaryKey(),\n  name: text(\"name\"),\n  email: varchar(\"email\", { length: 320 }),\n  loginMethod: varchar(\"loginMethod\", { length: 64 }),\n  role: mysqlEnum(\"role\", [\"user\", \"admin\"]).default(\"user\").notNull(),\n  createdAt: timestamp(\"createdAt\").defaultNow(),\n  lastSignedIn: timestamp(\"lastSignedIn\").defaultNow(),\n});\n\nexport type User = typeof users.$inferSelect;\nexport type InsertUser = typeof users.$inferInsert;\n\n// TODO: Add your tables here",
    "server/db.ts": "import { eq } from \"drizzle-orm\";\nimport { drizzle } from \"drizzle-orm/mysql2\";\nimport { InsertUser, users } from \"../drizzle/schema\";\nimport { ENV } from './_core/env';\n\nlet _db: ReturnType<typeof drizzle> | null = null;\n\n// Lazily create the drizzle instance so local tooling can run without a DB.\nexport async function getDb() {\n  if (!_db && process.env.DATABASE_URL) {\n    try {\n      _db = drizzle(process.env.DATABASE_URL);\n    } catch (error) {\n      console.warn(\"[Database] Failed to connect:\", error);\n      _db = null;\n    }\n  }\n  return _db;\n}\n\nexport async function upsertUser(user: InsertUser): Promise<void> {\n  if (!user.id) {\n    throw new Error(\"User ID is required for upsert\");\n  }\n\n  const db = await getDb();\n  if (!db) {\n    console.warn(\"[Database] Cannot upsert user: database not available\");\n    return;\n  }\n\n  try {\n    const values: InsertUser = {\n      id: user.id,\n    };\n    const updateSet: Record<string, unknown> = {};\n\n    const textFields = [\"name\", \"email\", \"loginMethod\"] as const;\n    type TextField = (typeof textFields)[number];\n\n    const assignNullable = (field: TextField) => {\n      const value = user[field];\n      if (value === undefined) return;\n      const normalized = value ?? null;\n      values[field] = normalized;\n      updateSet[field] = normalized;\n    };\n\n    textFields.forEach(assignNullable);\n\n    if (user.lastSignedIn !== undefined) {\n      values.lastSignedIn = user.lastSignedIn;\n      updateSet.lastSignedIn = user.lastSignedIn;\n    }\n    if (user.role === undefined) {\n      if (user.id === ENV.ownerId) {\n        user.role = 'admin';\n        values.role = 'admin';\n        updateSet.role = 'admin';\n      }\n    }\n\n    if (Object.keys(updateSet).length === 0) {\n      updateSet.lastSignedIn = new Date();\n    }\n\n    await db.insert(users).values(values).onDuplicateKeyUpdate({\n      set: updateSet,\n    });\n  } catch (error) {\n    console.error(\"[Database] Failed to upsert user:\", error);\n    throw error;\n  }\n}\n\nexport async function getUser(id: string) {\n  const db = await getDb();\n  if (!db) {\n    console.warn(\"[Database] Cannot get user: database not available\");\n    return undefined;\n  }\n\n  const result = await db.select().from(users).where(eq(users.id, id)).limit(1);\n\n  return result.length > 0 ? result[0] : undefined;\n}\n\n// TODO: add feature queries here as your schema grows.",
    "server/routers.ts": "import { COOKIE_NAME } from \"@shared/const\";\nimport { z } from \"zod\";\nimport { getSessionCookieOptions } from \"./_core/cookies\";\nimport { protectedProcedure, publicProcedure, router, adminProcedure } from \"./_core/trpc\";\n\nexport const appRouter = router({\n  system: router({\n    health: publicProcedure\n      .input(\n        z.object({\n          timestamp: z.number().min(0, \"timestamp cannot be negative\"),\n        })\n      )\n      .query(() => ({\n        ok: true,\n      })),\n  }),\n\n  auth: router({\n    me: publicProcedure.query(opts => opts.ctx.user),\n    logout: publicProcedure.mutation(({ ctx }) => {\n      const cookieOptions = getSessionCookieOptions(ctx.req);\n      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });\n      return {\n        success: true,\n      } as const;\n    }),\n  }),\n\n  // TODO: add feature routers here, e.g.\n  // todo: router({\n  //   list: protectedProcedure.query(({ ctx }) =>\n  //     db.getUserTodos(ctx.user.id)\n  //   ),\n  // }),\n});\n\nexport type AppRouter = typeof appRouter;",
    "client/src/App.tsx": "import { Toaster } from \"@/components/ui/sonner\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport NotFound from \"@/pages/NotFound\";\nimport { Route, Switch } from \"wouter\";\nimport ErrorBoundary from \"./components/ErrorBoundary\";\nimport { ThemeProvider } from \"./contexts/ThemeContext\";\nimport Home from \"./pages/Home\";\n\nfunction Router() {\n  // make sure to consider if you need authentication for certain routes\n  return (\n    <Switch>\n      <Route path={\"/\"} component={Home} />\n      <Route path={\"/404\"} component={NotFound} />\n      {/* Final fallback route */}\n      <Route component={NotFound} />\n    </Switch>\n  );\n}\n\n// NOTE: About Theme\n// - First choose a default theme according to your design style (dark or light bg), than change color palette in index.css\n//   to keep consistent foreground/background color across components\n// - If you want to make theme switchable, pass `switchable` ThemeProvider and use `useTheme` hook\n\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <ThemeProvider\n        defaultTheme=\"light\"\n        // switchable\n      >\n        <TooltipProvider>\n          <Toaster />\n          <Router />\n        </TooltipProvider>\n      </ThemeProvider>\n    </ErrorBoundary>\n  );\n}\n\nexport default App;",
    "client/src/lib/trpc.ts": "import { createTRPCReact } from \"@trpc/react-query\";\nimport type { AppRouter } from \"../../../server/routers\";\n\nexport const trpc = createTRPCReact<AppRouter>();",
    "client/src/pages/Home.tsx": "import { useAuth } from \"@/_core/hooks/useAuth\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Avatar, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { APP_LOGO, APP_TITLE, getLoginUrl } from \"@/const\";\nimport { AlertCircle, Loader2 } from \"lucide-react\";\n\n/**\n * Build polished modern webapp experiences. Visit the README for the full playbook.\n * All content in this page are only for example, delete if unneeded\n */\nexport default function Home() {\n  let { user, loading, error, isAuthenticated, logout } = useAuth();\n  // If theme is switchable in App.tsx, we can implement theme toggling like this:\n  // const { theme, toggleTheme } = useTheme();\n\n  const LoginBoxContent = () => {\n    return (\n      <>\n        <CardHeader className=\"text-center\">\n          {isAuthenticated ? (\n            <>\n              <CardTitle>Welcome back</CardTitle>\n              <CardDescription>You are signed in</CardDescription>\n            </>\n          ) : (\n            <>\n              <CardTitle>Get Started</CardTitle>\n              <CardDescription>Sign in to use this App</CardDescription>\n            </>\n          )}\n        </CardHeader>\n\n        <Separator />\n\n        <CardContent className=\"flex justify-center\">\n          {isAuthenticated ? (\n            <div className=\"flex items-center gap-4\">\n              <Avatar className=\"size-12\">\n                <AvatarFallback className=\"text-lg font-semibold\">\n                  {user?.name?.charAt(0).toUpperCase()}\n                </AvatarFallback>\n              </Avatar>\n              <div>\n                <div className=\"font-semibold\">{user?.name}</div>\n                <div className=\"text-sm text-muted-foreground\">\n                  {user?.email}\n                </div>\n              </div>\n            </div>\n          ) : (\n            <Button\n              className=\"w-full\"\n              size=\"lg\"\n              onClick={() => (window.location.href = getLoginUrl())}\n            >\n              Sign In\n            </Button>\n          )}\n        </CardContent>\n      </>\n    );\n  };\n\n  return (\n    <div className=\"min-h-screen flex flex-col\">\n      <header className=\"w-full border-b px-4 flex items-center justify-between h-14\">\n        <div className=\"flex items-center gap-2\">\n          <img\n            src={APP_LOGO}\n            className=\"h-8 w-8 rounded-lg border-border bg-background object-cover\"\n          />\n          <span className=\"text-xl font-bold\">{APP_TITLE}</span>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {isAuthenticated && (\n            <Button variant=\"outline\" onClick={logout}>\n              Sign Out\n            </Button>\n          )}\n        </div>\n      </header>\n\n      <main className=\"flex-1 flex flex-col items-center justify-center p-6\">\n        <Card style={{ minWidth: \"350px\" }}>\n          {loading ? (\n            <div className=\"flex items-center justify-center p-4\">\n              {/* Show loading at component level, not page level - keeps UI interactive */}\n              <Loader2 className=\"animate-spin\" />\n            </div>\n          ) : (\n            <LoginBoxContent />\n          )}\n        </Card>\n\n        {error && (\n          <Alert variant=\"destructive\">\n            <AlertCircle />\n            <AlertDescription>{error.message}</AlertDescription>\n          </Alert>\n        )}\n      </main>\n    </div>\n  );\n}"
  }
}
